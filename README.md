1

Класс - это чертёж, шаблон для создания объектов (определяет поля и методы)

Объект - конкретный экземпляр класса с кокретными полями

Конструктор - метод, который вызывается при создании объекта класса (инициализация объекта)

2

Функция - выполняет определенную задачу и может находиться за пределами классов

Метод - функция, которая является частью объкта, они определяются внутри классов и описывают поведение объектов

Инкапсуляция (private, public, default, protected) - скрытие внутренней реализации и данных от посторонних

3

Конструтор по умолчанию - не принимает аргументы и автоматически инициализирует поля объекта значениями по умолчанию

Конструктор параметризированный - принимает параметры и по ним инициализирует поля объекта

Статические поля - принадлежит не объекту класса, а самому классу. Общие для всех объектов

Обычные поля - принадлежит каждому объекту отдельно

4

Статический метод - привязан к самому классу, а не к объетам и может быть вызван без создания экземпляра класса

Обычный метод - привязан к объекту и для вызова надо создать экземпляр

Полиморфизм - один и тот же метод реализуется по разному

5

Интерфейс - содержит абстрактный метод, который содержит только сигнатуры, которые должны быть реализованы в классе

Абстрактный класс - может содержать как абстрактный метод, так и реализацию метода

Super - используется для обрашения к методам и конструторам родительского класса

6

Перезагрузка метода (Overloading) - создание нескольких методов с одиннаковыми именем, но разными параметрами

Переопрделение метода - дочерний класс переопределяет методы родительского

Наследование одиночное (Single) - класс может наследовать только один родитель, для предотвращения проблем с множественным

Наследование множественное (Multiple) - позволяет классам реализовать несколько интерфейсов

7

this & self - ссылка на текущий объект, в контексте где он был вызван, ипользуется только в нестатичных методах, для избежания конфликтов имен между полем и параметрами

поле Экземпляра - принадлежит кокретному объекту, каждый объект может иметь собственное значение

поле Класса (static) - принадлежит всему классу, поля общие для всех объектов

8

В джава есть два вида исключений:

Error - ошибки, которые нельзя обработать
Exception (Checked, Unchecked) - исключения, с которыми можно работать
Все исключения можно перехватить через try/catch

try/catch - в try пишется код, который может вызвать ошибку, а в catch что делается если возникла эта ошибка, также есть finaly, который выполняется в любом случае

9

Массив - фиксированный размер, все элементы одного типа, индексация

Список - динамическая длинна, гибкость типов, add, remove, get

Перезагрузка оператора - изменение поведения стандартного оператора

Пайтон позволяет перезагружать операторы, а джава нет, но можно перезагрузить методы

10

iterable - интерфейс, который представляет коллекцию объектов, по которой можно итерировать

iterator - интерфейс, который позваляет перебирать элементы, извлекая их 1 by 1

yeld в Пайтон - используюется для создания генераторов (функций, которые можно приостановить и возобновить), возвращает объект который можно итерирвать

11

Паттерн Singleton - порождающий паттерн, у класса только один экземпляр, обеспечивает глобальный доступ к этому экзумпляру
private Singleton() {}

public static Singleton getInstance() {
	if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
12

Паттерн Factory - пораждающий паттерн, предоставляет интерфейс для создания объектов без указания конкретных классов, повышает гибкость делигируя создание объектов дочерним классам

Конструктор создает объект только одного типа (класса)

Фабричный возварщает объекты различных типов, позволяя создавать объекты различных подклассов

13

Паттерн Observer - поведенческий паттерн, позволяет объектам продписываться на события в другом объекте и получать уведомления о изменениях состояния этого объекта

В событийной модели объект уведомляет наблюдателей о событии, в поллинге наблюдатель регулярно запрашивает данные

14

Паттерн Strategy - позволяет выбрать алгоритм поведения в зависимости от ситуации путём внедрения разных стратегий (методов поведения)

Применение: выбор оплаты, алгоритмы сортировки, навигация поиска (типизация в пайтон)

15

Паттерн Adapter - позволяет объектам с несовместимыми интерфейсами работать вместе, создаёт мост между двумя интерфейсами, адаптируя один интерфейс для другого

Преминение: интерфейсы баз данных, работа с устаревшими библиотеками, работа с разными API

16

SOLID: принцип единственной ответственности. Каждый класс или функция должны выполнять только одну задачу. Это означает, что все их методы и свойства должны быть связаны с этой одной обязанностью.

SOLID: принцип открытости/закрытости. Существующий код (например, класс) должен быть закрыт для внесения изменений, но открыт для добавления новой функциональности. Новую функциональность можно добавить через расширение, например, с помощью наследования или композиции, не изменяя исходный код.

17

SOLID: принцип подстановки Барбары Лисков. Наследники должны полностью заменять своих родителей, не ломая программу и не требуя специальных проверок (квадрат должен вести себя как прямоугольник).

SOLID: принцип разделения интерфейсов. Лучше иметь много маленьких, специализированных интерфейсов, чем один большой, который заставляет классы реализовывать ненужные им методы.

18

SOLID: принцип инверсии зависимостей. Модули верхнего уровня должны зависеть от абстракций (интерфейсов), а не от конкретных реализаций (деталей). Детали подключаются извне.

Внедрение зависимостей (DI) - это когда класс получает нужные ему инструменты (зависимости) снаружи, а не создает их сам внутри себя. Это позволяет легко подменять реальные зависимости на тестовые "заглушки" и делает код гибким, слабо связанным и простым для тестирования.

19

Класс - это чертеж для создания полноценного объекта, который объединяет в себе как данные (характеристики), так и поведение (методы или функции).

Структура данных, в отличие от класса, является более простым контейнером, предназначенным в основном для группировки и хранения только самих данных, без сложной логики и методов.

Классы поддерживают все принципы объектно-ориентированного программирования (наследование, полиморфизм), а структуры обычно служат для передачи информации.

Value types (типы значений) хранят сами данные прямо в переменной; при копировании создается независимая копия, и изменение одной не затронет другую (как с наличными деньгами).

Reference types (ссылочные типы) хранят только адрес (ссылку) на данные в памяти; при копировании копируется только адрес, и обе переменные указывают на одно и то же место, поэтому изменение данных через одну переменную будет видно и через другую (как с банковской картой, указывающей на один счет).

20

Методы toString() в Java и __str__() в Python используются, чтобы предоставить понятное текстовое описание объекта при его выводе на печать. Переопределение этих методов позволяет вместо технического адреса в памяти увидеть полезную информацию о состоянии объекта. Это помогает при отладке и логировании данных.

В Java оператор == сравнивает ссылки, то есть проверяет, являются ли две переменные одним и тем же объектом в памяти. Метод equals() сравнивает содержимое объектов, и его обычно переопределяют для определения логического равенства по заданным полям (например, по ID пользователя).

В Python оператор == сравнивает содержимое (значения), вызывая метод __eq__(), и его поведение по умолчанию схоже с переопределенным equals() в Java. Если же в Python вам нужно проверить, указывают ли две переменные на один и тот же объект в памяти (аналог Java ==), используется оператор is.

21

Декораторы - это функции, которые изменяют поведение других функций или классов. Они позволяют добавлять функциональность без изменения исходного кода.

Декоратор для функции: Функция, которая принимает другую функцию в качестве аргумента

Декоратор для класса: Декоратор для классов работает аналогично, но принимает класс в качестве аргумента.

Аннотации в Java — это метаданные, которые можно добавлять к классам, методам, полям и параметрам для предоставления дополнительной информации. Аннотации могут быть использованы, например, фреймворками или инструментами для генерации кода, проверки и т.д.

Атрибуты (поля) в классе Java: Поля — это переменные, которые определяются внутри класса. Они могут быть различного типа, доступа и могут быть статическими.

22

Генерация объектов - В Java объекты генерируются через оператор new. Для этого используется конструктор класса, который инициализирует новый объект.

Клонирование объекта в Java — это создание точной копии уже существующего объекта. Java предоставляет встроенный механизм клонирования через метод clone(), который находится в классе Object. Для того чтобы класс мог быть клонирован, он должен реализовать интерфейс Cloneable.

При поверхностном копировании создается новый объект, но если объект содержит ссылки на другие объекты (например, массивы или другие классы), то эти вложенные объекты не копируются. Вместо этого сохраняются ссылки на те же самые объекты. Таким образом, любые изменения во вложенных объектах будут отражаться на обоих объектах — исходном и клонированном.

При глубоком копировании создается полностью новый объект, и все объекты, на которые он ссылается, также копируются. То есть создаются новые экземпляры для всех вложенных объектов, и они не будут зависеть от исходного объекта. Глубокое копирование позволяет создать полностью независимую копию объекта, включая все его вложенные структуры.

23 Приватные атрибуты — это атрибуты класса, которые не могут быть напрямую изменены или прочитаны извне, что повышает инкапсуляцию.

Назначение: Защита данных внутри объекта, предотвращение их случайной модификации или доступа из других классов или внешнего кода. Часто используется для реализации бизнес-логики.

Реализация:

В Python атрибуты с префиксом _ или __ считаются приватными. Префикс __ также инициирует name mangling — изменение имени атрибута, чтобы его было сложнее изменить из внешнего кода.

В Java атрибуты по умолчанию private, если явно не указано другое

Геттеры и сеттеры: управление доступом
Геттеры и сеттеры — методы, которые управляют доступом к приватным атрибутам объекта.

Геттер (getter) — это метод, который позволяет получить значение приватного атрибута.

Сеттер (setter) — это метод, который позволяет изменить значение приватного атрибута.

Назначение:

Геттеры и сеттеры используются для управления доступом к атрибутам, при этом можно добавить логику (например, валидацию значений) при изменении данных.
Пример:

Python: через свойство (@property).

Java: явно через методы get() и set().

24

3.Дескрипторы в Python: суть и применение

Дескрипторы — это объекты, которые управляют доступом к атрибутам в Python. Они используются для реализации логики при доступе, изменении или удалении атрибутов объекта.

Суть: Дескрипторы реализуют один или несколько из следующих методов:

__get__(self, obj, type) — для получения значения.

__set__(self, obj, value) — для установки значения.

__delete__(self, obj) — для удаления атрибута.

Применение: Дескрипторы используются для реализации валидации данных, логирования доступа, ленивой загрузки и других целей.

Альтернативы дескрипторам: property, __setattr__

property (Python) — позволяет создавать геттеры и сеттеры для атрибутов с использованием декораторов. Это проще и удобнее, чем использование дескрипторов.
__setattr__ — метод в Python, который вызывается при попытке установить атрибут объекта. Это позволяет вам перехватывать установку атрибутов и добавлять дополнительную логику.
25

Абстрактные классы и интерфейсы: что выбрать? зависит от того, хотите ли вы использовать общую реализацию для некоторых методов (abstract class), или только объявить контракт без реализации (interface).

Абстрактные классы:

Определяют базовый класс с абстрактными методами, которые должны быть реализованы в подклассах.

Могут иметь как абстрактные методы, так и обычные реализации.

В Python это ABC (Abstract Base Class), в Java — abstract.

Интерфейсы:

Описание набора методов без реализации. Все методы в интерфейсе должны быть реализованы в классах.

В Python можно использовать просто классы без реализации, или через ABC.

В Java интерфейс не может содержать реализации (до Java 8, а начиная с Java 8 — могут быть дефолтные методы).

Отличие duck typing (Python) и строгой типизации (Java)

Duck typing (Python): Фраза "If it looks like a duck, quacks like a duck, it’s a duck". Это означает, что тип объекта определяется не по его заявленному типу, а по его поведению (методы и атрибуты, которые он поддерживает). В Python типы данных определяются динамически, и проверка типов происходит во время выполнения.

Строгая типизация (Java): В Java типы данных проверяются во время компиляции. Каждый объект должен быть явного типа, и попытка использовать объект не того типа вызовет ошибку компиляции.

26

Коллекции: сравнение List, Set, Map

List:
Коллекция, которая хранит элементы в определённом порядке (индексы). Может содержать дубликаты.
Пример: ArrayList в Java, list в Python.
Set:
Коллекция, которая хранит только уникальные элементы. Порядок хранения элементов не гарантирован.
Пример: HashSet в Java, set в Python.
Map:
Коллекция, которая хранит пары "ключ-значение". Ключи уникальны.
Пример: HashMap в Java, dict в Python.
Сравнение:

List — порядок и дубликаты.
Set — уникальные элементы, порядок не гарантирован.
Map — ключи уникальны, ассоциированные значения.
Хэш-таблицы: принципы работы

Хэш-таблица — это структура данных, которая хранит элементы в виде пар "ключ-значение", используя хэш-функцию для вычисления индекса, где будет храниться элемент. Преимущество хэш-таблицы — быстрый доступ по ключу.

9. Паттерн Prototype: идея и назначение
Prototype — это паттерн, который позволяет создавать новые объекты, копируя существующие, а не создавая их с нуля. Это особенно полезно, когда создание нового объекта дорогостоящее.

Назначение: создание объектов на основе существующего образца, улучшение производительности и уменьшение затрат на создание сложных объектов.

10. Отличие Prototype от Factory
Prototype: используется для клонирования объектов, где уже существует образец. Клонирование позволяет легко создать новые объекты.

Factory: создаёт новые объекты на основе некоторых входных параметров, но не обязательно копирует их.

11. Паттерн Builder: назначение
Builder — паттерн, который позволяет создавать сложные объекты пошагово. Он помогает скрыть сложность создания объекта и позволяет легко изменять процесс создания.

Назначение: создание объектов с множеством параметров или шагов, которые могут быть добавлены/изменены динамически.

12. Отличие Builder от Factory
Builder: используется для пошагового создания сложных объектов, где нужно собрать объект из множества частей.

Factory: создает объект целиком, основываясь на входных данных.

13. Современные возможности ООП: Generics (Java) и Generics/Typing (Python)
Generics в Java: позволяют создавать классы, интерфейсы и методы с параметрами типа. Это позволяет избежать дублирования кода и повышает типовую безопасность.

Generics/Typing в Python: Python использует аннотации типов и библиотеку typing для статической типизации и generic-классов. Однако, Python остается динамически типизированным языком.

14. Сравнение ООП и функционального программирования
ООП (Объектно-Ориентированное Программирование): фокусируется на объектах, которые инкапсулируют данные и поведение. Основные концепции — инкапсуляция, наследование, полиморфизм.

Функциональное программирование: акцент на функциях как первых классах, неизменяемости данных, чистых функциях и композиции функций.
